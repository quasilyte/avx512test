package main

import (
	"bytes"
	"flag"
	"fmt"
	"io/ioutil"
	"log"
	"os"
	"path/filepath"
	"sort"
	"strings"
	"text/template"

	"github.com/quasilyte/avx512test/internal/x86encode"
	"golang.org/x/arch/x86/x86csv"
)

type arguments struct {
	x86csv    string
	output    string
	debug     bool
	commented bool
}

type context struct {
	args  *arguments
	insts []*x86csv.Inst

	peeks map[string]int

	testLineByAsm map[string]*testLine
}

type testLine struct {
	Asm   string // Asm string in Go syntax
	Enc   string // Encoding string, can contain several or-separated encodings
	cpuid string // Normalized CPUID
}

func main() {
	var ctx context

	steps := []struct {
		name string
		fn   func() error
	}{
		{"parse flags", ctx.parseFlags},
		{"init context", ctx.init},
		{"prepare output dir", ctx.prepareOutputDir},
		{"read x86 csv", ctx.readCSV},
		{"filter insts", ctx.filterInsts},
		{"generate tests", ctx.generateTests},
		{"write output", ctx.writeOutput},
	}

	for _, step := range steps {
		if err := step.fn(); err != nil {
			log.Fatalf("%s: %+v", step.name, err)
		}
		ctx.debugf("finished %q step", step.name)
	}
}

func (ctx *context) parseFlags() error {
	var args arguments

	flag.StringVar(&args.x86csv, "x86csv", "x86.csv",
		`Where to find suitable x86.csv file`)
	flag.StringVar(&args.output, "output", "output",
		`Where to put generated encoder test files`)
	flag.BoolVar(&args.debug, "debug", false,
		`Whether to print extra output that is useful for debugging`)
	flag.BoolVar(&args.commented, "commented", false,
		`Whether to output all test lines under TODO comment`)

	flag.Parse()

	if args.x86csv == "" {
		return fmt.Errorf("-x86csv can't be empty")
	}

	ctx.args = &args

	return nil
}

func (ctx *context) init() error {
	ctx.peeks = map[string]int{}
	ctx.testLineByAsm = map[string]*testLine{}

	return nil
}

func (ctx *context) prepareOutputDir() error {
	return os.MkdirAll(ctx.args.output, 0775)
}

func (ctx *context) readCSV() error {
	f, err := os.Open(ctx.args.x86csv)
	if err != nil {
		return fmt.Errorf("open x86csv file: %v", err)
	}
	defer f.Close()

	insts, err := x86csv.NewReader(f).ReadAll()
	if err != nil {
		return fmt.Errorf("decode x86csv: %v", err)
	}

	ctx.insts = insts

	return nil
}

func (ctx *context) filterInsts() error {
	insts := ctx.insts[:0]

	skipByGoOpcode := map[string]bool{
		"VPEXTRW": true,
		"VMOVQ":   true,
		"VMOVHPD": true,
		"VMOVLPD": true,
	}

	for _, inst := range ctx.insts {
		switch {
		case inst.Mode64 != "V":
			continue // Not valid in 64-bit mode
		case strings.Contains(inst.IntelOpcode(), "NOP"):
			continue // Skip all kinds of NO-OPs
		case !strings.Contains(inst.CPUID, "AVX512"):
			continue // Not an AVX-512 form/instruction
		case skipByGoOpcode[inst.GoOpcode()]:
			continue // Explicitly skipped
		}

		insts = append(insts, inst)
	}

	ctx.insts = insts

	return nil
}

func (ctx *context) generateTests() error {
	for _, inst := range ctx.insts {
		if err := ctx.generateInstTests(inst); err != nil {
			return fmt.Errorf("generate tests: %s: %v", inst.Go, err)
		}
	}

	return nil
}

func (ctx *context) writeOutput() error {
	testsByCPUID := map[string][]*testLine{}

	for _, test := range ctx.testLineByAsm {
		testsByCPUID[test.cpuid] = append(testsByCPUID[test.cpuid], test)
	}

	// We need *some* sorting to avoid unwanted diffs between program runs.
	for _, tests := range testsByCPUID {
		sort.SliceStable(tests, func(i, j int) bool {
			return tests[i].Asm < tests[j].Asm
		})
	}

	cpuid2filename := map[string]string{
		"AES":              "aes_avx512f",
		"GFNI":             "gfni_avx512f",
		"VPCLMULQDQ":       "vpclmulqdq_avx512f",
		"AVX512BW":         "avx512bw",
		"AVX512CD":         "avx512cd",
		"AVX512DQ":         "avx512dq",
		"AVX512ER":         "avx512er",
		"AVX512F":          "avx512f",
		"AVX512PF":         "avx512pf",
		"AVX512_4FMAPS":    "avx512_4fmaps",
		"AVX512_4VNNIW":    "avx512_4vnniw",
		"AVX512_BITALG":    "avx512_bitalg",
		"AVX512_IFMA":      "avx512_ifma",
		"AVX512_VBMI":      "avx512_vbmi",
		"AVX512_VBMI2":     "avx512_vbmi2",
		"AVX512_VNNI":      "avx512_vnni",
		"AVX512_VPOPCNTDQ": "avx512_vpopcntdq",
	}

	testFileTemplate := template.Must(template.New("asmtest").Parse(`// Code generated by avx512test. DO NOT EDIT.

#include "../../../../../../runtime/textflag.h"

TEXT asmtest_{{.Name}}(SB), NOSPLIT, $0
{{ range .Tests }}
  {{- if $.Commented }}
    {{- printf "\t//TODO: %-50s // %s\n" .Asm .Enc }}
  {{- else }}
    {{- printf "\t%-50s // %s\n" .Asm .Enc }}
  {{- end }}
{{- end }}
{{- printf "\tRET" }}
`))

	for cpuid, tests := range testsByCPUID {
		filename := cpuid2filename[cpuid]

		var tdata struct {
			Commented bool
			Name      string
			Tests     []*testLine
		}
		tdata.Commented = ctx.args.commented
		tdata.Name = filename
		tdata.Tests = tests

		var buf bytes.Buffer
		if err := testFileTemplate.Execute(&buf, tdata); err != nil {
			return fmt.Errorf("%s tests: %v", cpuid, err)
		}
		outFilename := filepath.Join(ctx.args.output, filename+".s")
		if err := ioutil.WriteFile(outFilename, buf.Bytes(), 0644); err != nil {
			return fmt.Errorf("%s tests: %v", cpuid, err)
		}
	}

	return nil
}

func (ctx *context) generateInstTests(inst *x86csv.Inst) error {
	var argLists [][]instArg
	for _, arg := range inst.IntelArgs() {
		argLists = append(argLists, ctx.parseArg(inst, arg))
	}
	argLists = argsCartesianProd(argLists)

	for _, argList := range argLists {
		asm := goAsmString(inst, argList)

		var encodings []string
		for _, rexw := range instREXW(inst) {
			for _, vl := range instVL(inst) {
				params := []x86encode.InstParam{rexw, vl}
				enc, err := ctx.encodeInst(inst, argList, params)
				if err != nil {
					log.Printf("%q <%s,%s>: encoder error: %v",
						asm, rexw, vl, err)
					continue
				}
				if enc == "" {
					log.Printf("%q <%s,%s>: empty encoding string",
						asm, rexw, vl)
					continue
				}
				if !strings.HasPrefix(enc, "62") && evexEncoded(inst) {
					ctx.debugf("%q <%s,%s>: skip non-evex (enc=%q)\n",
						asm, rexw, vl, enc)
					continue
				}
				encodings = append(encodings, enc)
			}
		}

		if len(encodings) == 0 {
			ctx.debugf("%q: empty test set", asm)
			continue
		}

		test := ctx.testLineByAsm[asm]
		if test != nil {
			ctx.debugf("%q: skip duplicate (%s)", asm, test.Enc)
			continue
		}

		ctx.testLineByAsm[asm] = &testLine{
			Asm:   asm,
			Enc:   strings.Join(encodings, " or "),
			cpuid: normalizeCPUID(inst.CPUID),
		}
	}

	return nil
}

func (ctx *context) encodeInst(inst *x86csv.Inst, argList []instArg, params []x86encode.InstParam) (string, error) {
	switch inst.DataSize {
	case "8":
		params = append(params, x86encode.ParamEOSZ8)
	case "16":
		params = append(params, x86encode.ParamEOSZ16)
	case "32":
		params = append(params, x86encode.ParamEOSZ32)
	case "64":
		params = append(params, x86encode.ParamEOSZ64)
	}

	args := make([]x86encode.Argument, len(argList))
	for i := range argList {
		if mem, ok := argList[i].data.(*x86encode.MemArgument); ok {
			// For AVX512 special handling of displacement is required.
			// Copy of mem is required as it's shared among several args
			// and we're about to modify it.
			copied := *mem
			if strings.Contains(inst.Tags, "scale") && !inst.HasTag("scale1") {
				if copied.Disp != 0 {
					copied.DispWidth = x86encode.Disp32
				}
			}
			argList[i].data = &copied
		}
		args[i] = argList[i].data
	}

	return x86encode.ToHexString(&x86encode.Inst{
		Opcode: inst.IntelOpcode(),
		Params: params,
		Args:   args,
	})
}

func (ctx *context) parseArg(inst *x86csv.Inst, arg string) []instArg {
	arg = normalizeArg(inst, arg)

	if arglist := instArgsBySyntax[arg]; arglist != nil {
		npeeks, ok := peeksPerArgBySyntax[arg]
		if !ok {
			panic(fmt.Sprintf("undefined npeeks for %q", arg))
		}

		ret := make([]instArg, npeeks)
		i := ctx.peeks[arg]
		for j := 0; j < npeeks; j++ {
			ret[j] = arglist[i]
			i++
			if i >= len(arglist) {
				i = 0
			}
		}
		ctx.peeks[arg] = i

		return ret
	}

	switch arg {
	case "{k}{z}", "{k1-k7}":
		// Ignore zeroing.
		return ctx.parseArg(inst, "{k}")
	case "r/m32":
		return ctx.parseArgs(inst, "rmr32", "m32")
	case "r/m64":
		return ctx.parseArgs(inst, "rmr64", "m64")
	default:
		if strings.Contains(arg, "/m") {
			return ctx.parseArgs(inst, strings.Split(arg, "/")...)
		}
		panic(fmt.Sprintf("unhandled %q arg", arg))
	}
}

func (ctx *context) parseArgs(inst *x86csv.Inst, args ...string) []instArg {
	var parsed []instArg
	for _, arg := range args {
		parsed = append(parsed, ctx.parseArg(inst, arg)...)
	}
	return parsed
}

func (ctx *context) debugf(format string, args ...interface{}) {
	if ctx.args.debug {
		log.Printf("debug: "+format, args...)
	}

}
